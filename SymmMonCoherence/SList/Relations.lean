/-
Copyright (c) 2025 Robin Carlier. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Robin Carlier
-/
module

public import SymmMonCoherence.SList.Basic
public import SymmMonCoherence.CategoryWeight
public import SymmMonCoherence.SymmetricGroupCoxeterSystem
/-! # Characterizing the morphisms in Symmetric lists.

In this file, we characterize morphisms in the category `SList C` in the
following way: to each morphism `f : L ‚ü∂ L'`, one can attach a formal permutation
`formalPerm f : Equiv.Perm ‚Ñï`, and two morphisms are equal if and only if the
attached formal permutations are equal.

The idea is simple: the relations that define symmetric lists are essentially in
one-to-one correspondence with the relations that present
the symmetric group as a Coxeter group; this is the argument one usually goes with
in pen-and-paper mathematics (see e.g [MacLane CWM]), but the formal realization of this argument
is in fact rather involved.

To define the formal permutation attached to a morphism, we first attach labels that live
in `FreeMonoid ‚Ñï` to every (formal composition of) generating morphisms: the `swap` morphism
is labelled by `0`, and prepending an element to a morphism "shifts" the label by
one: e.g `a::b::(swap c d (e::nil)) : [a,b,c,d,e] ‚ü∂ [a,b,d,c,e]` is labelled with `2`.
This way, a generating morphism is labelled with the first index of the list that
gets swapped, formal compositions of generating morphisms (i.e morphism in `FreeSListQuiv C`)
have elements in `FreeMonoid ‚Ñï` ("words") attached to them.

The relations between the morphisms make it so that two morphisms in relation will have
labels related by the relation defined by the Coxeter matrix Ainf, and hence morphisms in
`SList C` have a well-defined label in the monoid `Ainf.Monoid` (which is isomorphic to the
corresponding Coxeter Group). As one can realize this monoid as a multiplicative subset of
`Equiv.Perm ‚Ñï`, this defines the formal permutation of a morphism: by this definition, the
`swap` morphism gets sent to the permutation `Equiv.swap 0 1`, and
e.g `a::b::(swap c d (e::nil)) : [a,b,c,d,e] ‚ü∂ [a,b,d,c,e]` is labelled with `Equiv.swap 2 3`.
This definition realizes the idea that the "formal permutation" attached to a morphism is the
permutation of the indices of the source and target that this morphism performed.

The converse (that two morphisms with same formal permutations are equal) is harder:
one has to first work with formal compositions of generating morphisms
(i.e., morphisms in `FreeSListQuiv C`) and labels in free monoids and show that
1. Any two formal compositions of generating morphisms with same source, target and label are equal
2. Any two formal compositions of generating morphisms with same source and label have equal target
3. That for suitable labels and source, one can find formal compositions of generating morphisms out
of the given source with given label.
4. Using 1 and 2, that for each relation in the Coxeter matrix `Ainf`, one can find an
explicit morphisms whose label realizes these relations, and that these morphisms reduce to
identities in `SList`.
5. Using all of the points above and the definition of the equivalence relations generated by the
relations in Ainf and the equivalence relation generated by `CategoryTheory.Q‚ÇÅ.HomEquiv‚ÇÄ`,
show that any two paths are in relation if the corresponding labels in `Ainf.Monoid` are equal.

Point 4. is rather tedious as one needs to repeat essentially the same procedure for every morphism:
because of the inductive nature of generating morphisms:
one needs to decompose the source and target of the morphism, construct by hand a "candidate"
morphism with the right label, show that the original morphism is equal to the candidate
(since they have same label), and then show that the candidate morphism simplifies to an identity by
invoking the relations that define symmetric lists.

Point 5. hides the technicality from point 3. that labels need to be "suitable" in order to be
realized by explicit morphisms: by construction, paths of generating morphisms between lists
of length `n + 2` cannot have labels that are words involving natural numbers ‚â• n, so in point 5,
two words may *a priori* be related because of transitivity through words that are "too big".
One has in fact to use that `A‚Çô.Monoid` injects into `Ainf.Monoid`,
which essentially means that two words in `FreeMonoid ‚Ñï` involving only letters coming from
`Fin (n + 1)` are in relation for the relation that defines `Ainf.Monoid` if and only if they are
for the relation that defines `A‚Çô.Monoid`. This means that when generating the symmetric reflexive
closure of the base relation, one may assume that all extra words that appear (e.g for transitivity)
also only involve letters from `Fin (n + 1)`, which we are then able to realize as morphisms.

-/

@[expose] public section

attribute [-simp] CoxeterMatrix.toCoxeterSystem_simple
attribute [-simp] CategoryTheory.Paths.of_obj
attribute [-simp] CategoryTheory.Paths.of_map

universe u
namespace CategoryTheory.SList

variable {C : Type u}

namespace SListQuiv

/-- A base `‚Ñï`-valued label attached to a generating morphism. A swap morphism is valued
`0`, and prepending an element of `C` to a morphism adds 1 to the label.

Informally, this label records the "index" at which a variable swap occurs. -/
def labelling‚ÇÄ : Quiver.Labelling (SListQuiv C) ‚Ñï
  | _, _, .swap x y l => 0
  | _, _, .cons z f => labelling‚ÇÄ f + 1

/-- A `Fin (n + 1)`-valued label attached to a generating morphism. A swap morphism is valued
`0`, and prepending an element of `C` to a morphism adds 1 to the label.

Informally, this label records the "index" at which a variable swap occurs.

This way of thinking about the label is only well-defined if the length of the input is
large enough, but it is convenient to have it defined without restriction on the length. -/
def finLabelling‚ÇÄ (n : ‚Ñï) : Quiver.Labelling (SListQuiv C) (Fin (n + 1)) := fun _ _ f =>
  Fin.ofNat (n + 1) (labelling‚ÇÄ f)

/-- The labelling `labelling‚ÇÄ` as an element in `FreeGroup ‚Ñï`. -/
def labelling‚ÇÅ : Quiver.Labelling (SListQuiv C) (FreeGroup ‚Ñï) := fun _ _ f =>
    FreeGroup.of <| labelling‚ÇÄ f

/-- The labelling `labelling‚ÇÄ` as an element in `FreeMonoid ‚Ñï`. -/
def labelling‚ÇÅMon : Quiver.Labelling (SListQuiv C) (FreeMonoid ‚Ñï) := fun _ _ f =>
    FreeMonoid.of <| labelling‚ÇÄ f

/-- The labelling `finLabelling‚ÇÄ` as an element in `FreeMonoid (Fin (n + 1))`. -/
def finLabelling‚ÇÅMon (n : ‚Ñï) : Quiver.Labelling (SListQuiv C) (FreeMonoid (Fin (n + 1))) :=
  fun _ _ f => FreeMonoid.of <| finLabelling‚ÇÄ n f

lemma labelling‚ÇÅ_eq {i j : SListQuiv C} (f : i ‚ü∂ j) :
  labelling‚ÇÅ f = FreeMonoid.toFreeGroup _ (labelling‚ÇÅMon f) := rfl

def labelling‚ÇÇ : Quiver.Labelling (SListQuiv C) Ainf.Group := fun _ _ f =>
    Ainf.toCoxeterSystem.simple <| labelling‚ÇÄ f

def labelling‚ÇÇMon : Quiver.Labelling (SListQuiv C) Ainf.Monoid := fun _ _ f =>
  Ainf.groupToMonoid (labelling‚ÇÇ f)

def A‚ÇôLabelling (n : ‚Ñï) : Quiver.Labelling (SListQuiv C) (CoxeterMatrix.A‚Çô (n + 1)).Monoid :=
  fun _ _ f => PresentedMonoid.mk _ <| finLabelling‚ÇÅMon n f

lemma labelling‚ÇÄ_lt {i j : SListQuiv C} (f : i ‚ü∂ j) : labelling‚ÇÄ f + 1 < i.length := by
  induction f using SListQuiv.induction <;> grind [labelling‚ÇÄ]

lemma labelling‚ÇÄ_le {i j : SListQuiv C} (f : i ‚ü∂ j) : labelling‚ÇÄ f + 2 ‚â§ i.length := by
  induction f using SListQuiv.induction <;> grind [labelling‚ÇÄ]

lemma A‚ÇôLabelling_to_Ainf (n : ‚Ñï) {i j : SListQuiv C} (f : i ‚ü∂ j) (hn : n + 2 = i.length) :
    AnToAinfMonoid _ (A‚ÇôLabelling n f) = labelling‚ÇÇMon f := by
  induction f using SListQuiv.induction with
  | sw x y l =>
    dsimp [A‚ÇôLabelling, finLabelling‚ÇÅMon, finLabelling‚ÇÄ]
    suffices h : labelling‚ÇÄ (.swap x y l) % (n + 1) = labelling‚ÇÄ (.swap x y l) by
      rw [h]
      simp [labelling‚ÇÄ, labelling‚ÇÇMon, labelling‚ÇÇ, CoxeterMatrix.toCoxeterSystem_simple,
        CoxeterMatrix.groupToMonoid_simple]
    simp [labelling‚ÇÄ]
  | @cons x l l' f h =>
    dsimp [A‚ÇôLabelling, finLabelling‚ÇÅMon, finLabelling‚ÇÄ, labelling‚ÇÄ, labelling‚ÇÇMon, labelling‚ÇÇ]
    suffices h : (labelling‚ÇÄ f + 1) % (n + 1) = labelling‚ÇÄ f + 1 by
      rw [h]
      simp [CoxeterMatrix.toCoxeterSystem_simple]
    simp only [Nat.mod_succ_eq_iff_lt, Nat.succ_eq_add_one, add_lt_add_iff_right]
    have := labelling‚ÇÄ_le f
    grind

@[simp]
lemma labelling‚ÇÅ_swap (x y : C) (l : SListQuiv C) : labelling‚ÇÅ (.swap x y l) = .of 0 := rfl

@[simp]
lemma labelling‚ÇÇ_swap (x y : C) (l : SListQuiv C) : labelling‚ÇÇ (.swap x y l) =
    Ainf.toCoxeterSystem.simple 0 := rfl

namespace FreeSListQuiv

@[no_expose] def mkWeight {M : Type*} [Monoid M] (L : Quiver.Labelling (SListQuiv C) M) :
    weight (FreeSListQuiv C) M :=
  .mk (FreeSListQuiv.lift (fun _ ‚Ü¶ .op <| .star M) (fun {_ _} f ‚Ü¶ Quiver.Hom.op (L f)))

@[simp, grind =]
lemma mkWeight_app_Œπ {M : Type*} [Monoid M] {L : Quiver.Labelling (SListQuiv C) M}
    {x y : SListQuiv C} (f : x ‚ü∂ y) :
    (mkWeight L).app ((FreeSListQuiv.Œπ C).map f) = L f := by
  simp [weight.app_mk, mkWeight]

-- @[simp, grind =]
lemma mkWeight_app_swap {M : Type*} [Monoid M] {L : Quiver.Labelling (SListQuiv C) M}
    {x y : C} (l : FreeSListQuiv C) :
    (mkWeight L).app (FreeSListQuiv.swap x y l) = L (Œ≤‚ÇÄ_ x y (FreeSListQuiv.equiv l)) := by
  cases l
  simp only [‚Üê FreeSListQuiv.swap_eq, mkWeight_app_Œπ]
  rfl

end FreeSListQuiv

abbrev w‚ÇÄ : weight (FreeSListQuiv C) (FreeMonoid ‚Ñï) := FreeSListQuiv.mkWeight labelling‚ÇÅMon
abbrev w‚ÇÅ : weight (FreeSListQuiv C) (FreeGroup ‚Ñï) := FreeSListQuiv.mkWeight labelling‚ÇÅ
abbrev w‚ÇÇ : weight (FreeSListQuiv C) Ainf.Group := FreeSListQuiv.mkWeight labelling‚ÇÇ
abbrev w‚ÇÄFin (n : ‚Ñï) : weight (FreeSListQuiv C) (FreeMonoid (Fin (n + 1))) :=
  FreeSListQuiv.mkWeight (finLabelling‚ÇÅMon n)
abbrev wFin (n : ‚Ñï) : weight (FreeSListQuiv C) (CoxeterMatrix.A‚Çô (n + 1)).Monoid :=
  FreeSListQuiv.mkWeight (A‚ÇôLabelling n)

open scoped FreeSListQuiv

@[simp]
lemma w‚ÇÄ_swap (x y : C) (l : FreeSListQuiv C) : w‚ÇÄ.app (FreeSListQuiv.swap x y l) = .of 0 := by
  simp [FreeSListQuiv.mkWeight_app_swap, labelling‚ÇÅMon, labelling‚ÇÄ]

@[simp]
lemma w‚ÇÇ_swap (x y : C) (l : FreeSListQuiv C) :
    w‚ÇÇ.app (FreeSListQuiv.swap x y l) = Ainf.simple 0 := by
  simp only [FreeSListQuiv.mkWeight_app_swap, labelling‚ÇÇ_swap]
  rfl

@[simp]
lemma labelling‚ÇÅ_cons {i j : SListQuiv C} (f : i ‚ü∂ j) (x : C) :
    labelling‚ÇÅ (.cons x f) = shift' (labelling‚ÇÅ f) :=
  rfl

lemma labelling‚ÇÇ_eq {i j : SListQuiv C} (f : i ‚ü∂ j) :
    labelling‚ÇÇ f = PresentedGroup.mk _ (labelling‚ÇÅ f) :=
  rfl

@[simp]
lemma w‚ÇÅ_app_consPath {i j : FreeSListQuiv C} (f : i ‚ü∂ j) (x : C) :
    w‚ÇÅ.app (x ::_‚Çò f) = shift' (w‚ÇÅ.app f) := by
  induction f using FreeSListQuiv.hom_induction with
  | id => simp
  | @comp u v p q r h =>
    simp [h, ‚Üê FreeSListQuiv.cons_map_def]

lemma w‚ÇÇ_app_eq {i j : FreeSListQuiv C} (f : i ‚ü∂ j) :
    w‚ÇÇ.app f = PresentedGroup.mk _ (w‚ÇÅ.app f) := by
  induction f using FreeSListQuiv.hom_induction with
  | id => simp
  | comp p q r =>
    simp only [weight.weight_comp, r, FreeSListQuiv.mkWeight_app_Œπ, map_mul, mul_right_inj]
    rfl

lemma w‚ÇÇ_app_eq' {i j : FreeSListQuiv C} (f : i ‚ü∂ j) :
    Ainf.groupToMonoid (w‚ÇÇ.app f) = PresentedMonoid.mk _ (w‚ÇÄ.app f) := by
  induction f using FreeSListQuiv.hom_induction with
  | id => simp
  | comp p q h =>
    simp only [weight.weight_comp, FreeSListQuiv.mkWeight_app_Œπ, labelling‚ÇÇ_eq,
      labelling‚ÇÅ_eq, map_mul, h]
    rfl

@[simp]
lemma labelling‚ÇÇ_cons {i j : SListQuiv C} (f : i ‚ü∂ j) (x : C) :
    labelling‚ÇÇ (.cons x f) = Ainf.shift 1 (labelling‚ÇÇ f) :=
  rfl

@[simp]
lemma w‚ÇÇ_app_consPath {i j : FreeSListQuiv C} (f : i ‚ü∂ j) (x : C) :
    w‚ÇÇ.app (x ::_‚Çò f) = Ainf.shift 1 (w‚ÇÇ.app f) := by
  induction f using FreeSListQuiv.hom_induction with
  | id => simp
  | @comp u v p q h r => simp [r, ‚Üê FreeSListQuiv.cons_map_def]

private lemma ainfToPerm_w‚ÇÇ_apply_lt_of_lt {L‚ÇÅ L‚ÇÇ : FreeSListQuiv C}
    (f : L‚ÇÅ ‚ü∂ L‚ÇÇ) (i : ‚Ñï)
    (hi : i < L‚ÇÇ.toList.length) : (AinfToPerm (w‚ÇÇ.app f)) i < L‚ÇÅ.toList.length := by
  induction f using FreeSListQuiv.hom_induction generalizing i with
  | id => simpa using hi
  | @comp L‚ÇÅ L‚ÇÇ L‚ÇÉ p q hp =>
    simp only [FreeSListQuiv.Œπ_toList, toList_length] at hp hi
    have hl‚ÇÅ‚ÇÇ : L‚ÇÅ.length = L‚ÇÇ.length := FreeSListQuiv.length_eq_of_hom p
    have hl‚ÇÇ‚ÇÉ : L‚ÇÇ.length = L‚ÇÉ.length := FreeSListQuiv.length_eq_of_hom ((FreeSListQuiv.Œπ _).map q)
    simp only [weight.weight_comp, FreeSListQuiv.mkWeight_app_Œπ, labelling‚ÇÇ, map_mul,
      AinfToPerm_simple, Equiv.Perm.coe_mul, Function.comp_apply, FreeSListQuiv.Œπ_toList,
      toList_length, gt_iff_lt]
    apply hp
    grind [labelling‚ÇÄ_lt q]

theorem _root_.List.getElem_of_eq' {Œ± : Type*} {l : List Œ±} {i i' : Nat} (h : i = i')
    (w : i < l.length) :
    l[i] = l[i']'(h ‚ñ∏ w) := by cases h; rfl

private lemma getElem_toList_eq_perm_apply'
    {L‚ÇÅ L‚ÇÇ : SListQuiv C}
    (f : L‚ÇÅ.Hom L‚ÇÇ) (i : ‚Ñï)
    (hi : i < L‚ÇÇ.toList.length) :
    (L‚ÇÇ.toList)[i] =
    (L‚ÇÅ.toList)[(AinfToPerm (w‚ÇÇ.app (FreeSListQuiv.Œπ C |>.map f))) i]'
      (ainfToPerm_w‚ÇÇ_apply_lt_of_lt (FreeSListQuiv.Œπ C |>.map f) _ hi) := by
  induction f generalizing i with grind [labelling‚ÇÇ, labelling‚ÇÄ, AinfToPerm_simple]

private lemma getElem_toList_eq_perm_apply {L‚ÇÅ L‚ÇÇ : FreeSListQuiv C} (f : L‚ÇÅ ‚ü∂ L‚ÇÇ)
    (i : ‚Ñï) (hi : i < L‚ÇÇ.length) :
    (L‚ÇÇ.toList)[i] =
      (L‚ÇÅ.toList)[AinfToPerm (w‚ÇÇ.app f) i]'(ainfToPerm_w‚ÇÇ_apply_lt_of_lt f _ hi) := by
  induction f using FreeSListQuiv.hom_induction generalizing i with
  | id => simp
  | @comp l‚ÇÅ l‚ÇÇ l‚ÇÉ p q hr =>
    simp only [toList_length, FreeSListQuiv.Œπ_length, FreeSListQuiv.Œπ_toList, weight.weight_comp,
      FreeSListQuiv.mkWeight_app_Œπ, map_mul, Equiv.Perm.coe_mul, Function.comp_apply] at hi ‚ä¢ hr
    have := FreeSListQuiv.length_eq_of_hom p
    have := getElem_toList_eq_perm_apply' q
    simp only [toList_length, FreeSListQuiv.mkWeight_app_Œπ] at this
    rw [this i hi]
    have : (AinfToPerm (labelling‚ÇÇ q)) i < l‚ÇÇ.length := by
      simpa using ainfToPerm_w‚ÇÇ_apply_lt_of_lt
        ((FreeSListQuiv.Œπ C).map q) i hi
    exact hr (AinfToPerm (labelling‚ÇÇ q) i) this

lemma wFin_app_eq' (n : ‚Ñï) {i j : FreeSListQuiv C} (f : i ‚ü∂ j) :
    (wFin n).app f = PresentedMonoid.mk _ ((w‚ÇÄFin n).app f) := by
  induction f using FreeSListQuiv.hom_induction with
  | id => simp
  | comp p q h => simp [h, finLabelling‚ÇÅMon, A‚ÇôLabelling]

lemma w‚ÇÇ_app_eq_of_homEquiv
    {i j : FreeSListQuiv C} (f g : i ‚ü∂ j) (h : FreeSListQuiv.HomEquiv C f g) :
    w‚ÇÇ.app f = w‚ÇÇ.app g := by
  induction h with
  | swap_naturality‚ÇÄ X Y f =>
    simp only [weight.weight_comp, w‚ÇÇ_swap, w‚ÇÇ_app_consPath, FreeSListQuiv.mkWeight_app_Œπ]
    have e := Ainf.toCoxeterSystem.simple_mul_simple_pow 0 (labelling‚ÇÄ f + 1 + 1)
    simp only [Ainf_M, Matrix.of_apply, Nat.right_eq_add, Nat.add_eq_zero_iff, OfNat.ofNat_ne_zero,
      and_false, ‚ÜìreduceIte, one_ne_zero, and_self, zero_add, or_self, pow_two,
      mul_eq_one_iff_inv_eq, mul_inv_rev, CoxeterSystem.inv_simple] at e
    simpa [labelling‚ÇÇ, CoxeterMatrix.toCoxeterSystem_simple] using e.symm
  | swap_swap X Y l => simp
  | triple X Y Z l =>
    simp only [weight.weight_comp, w‚ÇÇ_swap, w‚ÇÇ_app_consPath, Ainf.shift_simple 1, zero_add]
    have e := Ainf.toCoxeterSystem.simple_mul_simple_pow 0 1
    simp only [Ainf_M, Matrix.of_apply, zero_ne_one, ‚ÜìreduceIte, Nat.reduceAdd,
      OfNat.ofNat_ne_zero, zero_add, or_true, pow_three, mul_eq_one_iff_inv_eq, mul_inv_rev,
      CoxeterSystem.inv_simple] at e
    have := congr($e * Ainf.toCoxeterSystem.simple 1)
    simpa [‚Üê mul_assoc] using this.symm
  | cons X f f' h‚ÇÄ hrec => grind [w‚ÇÇ_app_consPath]

lemma w‚ÇÇ_app_eq_of_compClosure_homEquiv {i j : FreeSListQuiv C} (f g : i ‚ü∂ j)
    (h : (HomRel.CompClosure (FreeSListQuiv.HomEquiv C)) f g) :
    w‚ÇÇ.app f = w‚ÇÇ.app g := by
  cases h with | intro i j f m‚ÇÅ m‚ÇÇ g h =>
  simpa using w‚ÇÇ_app_eq_of_homEquiv m‚ÇÅ m‚ÇÇ h

end SListQuiv

public section toAinf
open SListQuiv

def toAinf : weight (SList C) Ainf.Group :=
  .mk <| SList.lift w‚ÇÇ.F <| by
    intro x y f g h
    apply Quiver.Hom.unop_inj
    simp_rw [weight.app_eq]
    exact w‚ÇÇ_app_eq_of_homEquiv _ _ h

@[simp, grind =]
lemma toAinf_œÄ {l l' : FreeSListQuiv C} (f : l ‚ü∂ l') :
    toAinf.app ((œÄ C).map f) = w‚ÇÇ.app f := by
  simp only [toAinf, weight.app_mk]
  generalize_proofs h
  simp [lift_œÄ_obj (h := h), lift_œÄ_map (h := h), weight.app_eq]

@[simp, grind =]
lemma toAinf_swap (x y : C) (l : SList C) :
    toAinf.app (Œ≤~ x y l) = Ainf.simple 0 := by
  simp only [toAinf, weight.app_mk]
  rfl

@[simp, grind =]
lemma toAinf_cons (x : C) {l l' : SList C} (f : l ‚ü∂ l') :
    toAinf.app ((x>~).map f) = Ainf.shift 1 (toAinf.app f) := by
  simp only [toAinf, weight.app_mk]
  induction f with | @h u v f =>
  generalize_proofs h
  change ((lift w‚ÇÇ.F h).map (œÄ C |>.map <| x ::_‚Çò f)).unop = _
  simp [weight.app_eq, SList.lift_œÄ_obj (h := h), SList.lift_œÄ_map (h := h)]

end toAinf

public section toPerm
open SListQuiv

def toPerm : weight (SList C) (Equiv.Perm ‚Ñï) :=
  toAinf.postComp AinfToPerm

@[simp, grind =]
lemma toPerm_swap (x y : C) (l : SList C) :
    toPerm.app (Œ≤~ x y l) = Equiv.swap 0 1 := by
  simp [toPerm]

@[simp, grind =]
lemma toPerm_app_cons_apply_zero (x : C) {l l' : SList C} (f : l ‚ü∂ l') :
    toPerm.app ((x>~).map f) 0 = 0 := by
  simp only [toPerm, weight.postComp_app, toAinf_cons]
  generalize toAinf.app f = u
  induction u using Ainf.toCoxeterSystem.simple_induction with
  | simple i => simp only [Ainf.shift_simple' 1, AinfToPerm_simple]; grind
  | one => simp
  | mul w w' h‚ÇÄ h‚ÇÄ' => simp [h‚ÇÄ, h‚ÇÄ']

@[simp, grind =]
lemma toPerm_app_cons_apply_succ (x : C) {l l' : SList C} (f : l ‚ü∂ l') (k : ‚Ñï) :
    toPerm.app ((x>~).map f) (k + 1) = (toPerm.app f) k + 1 := by
  simp only [toPerm, weight.postComp_app, toAinf_cons]
  generalize toAinf.app f = u
  induction u using Ainf.toCoxeterSystem.simple_induction generalizing k with
  | simple i => simp only [Ainf.shift_simple' 1, AinfToPerm_simple]; grind
  | one => simp
  | mul w w' h‚ÇÄ h‚ÇÄ' => simp [h‚ÇÄ, h‚ÇÄ']

theorem toPerm_app_eq_of_lt {x y : SList C} (f : x ‚ü∂ y) (k : ‚Ñï) (hk : y.length ‚â§ k) :
    (toPerm.app f) k = k := by
  simp only [toPerm, weight.postComp_app]
  induction f using SList.hom_induction with | h f =>
  induction f using FreeSListQuiv.hom_induction with
  | id => simp
  | comp p q hq =>
    have := SListQuiv.length_eq_of_hom q
    simp only [Functor.map_comp, weight.weight_comp, toAinf_œÄ, FreeSListQuiv.mkWeight_app_Œπ,
      labelling‚ÇÇ, map_mul, AinfToPerm_simple, Equiv.Perm.coe_mul, Function.comp_apply]
    have := labelling‚ÇÄ_lt q
    grind

@[grind .]
theorem toPerm_app_lt_of_lt {L‚ÇÅ L‚ÇÇ : SList C} (f : L‚ÇÅ ‚ü∂ L‚ÇÇ) (k : ‚Ñï) (hk : k < L‚ÇÇ.length) :
    (toPerm.app f) k < L‚ÇÅ.length := by
  by_contra!
  have := toPerm_app_eq_of_lt (inv f) (toPerm.app f k) this
  simp only [weight.app_inv, Equiv.Perm.coe_inv, Equiv.symm_apply_apply] at this
  grind [SList.length_eq_of_hom f]

theorem getElem_toList_toPerm {L‚ÇÅ L‚ÇÇ : SList C} (f : L‚ÇÅ ‚ü∂ L‚ÇÇ) (i : ‚Ñï) (hi : i < L‚ÇÇ.length) :
    L‚ÇÇ.toList[i] = L‚ÇÅ.toList[toPerm.app f i]'(toPerm_app_lt_of_lt f i hi) := by
  cases f with | @h x y f =>
  simp only [œÄ_obj_toList, toPerm, weight.postComp_app, toAinf_œÄ]
  exact getElem_toList_eq_perm_apply f _ _

end toPerm

namespace SListQuiv

lemma eq_of_labelling‚ÇÄ_eq {i j : (SListQuiv C)} {f g : i ‚ü∂ j}
    (h : labelling‚ÇÄ f = labelling‚ÇÄ g) :
    f = g := by
  induction f using SListQuiv.induction with
  | sw x y l =>
    cases g using SListQuiv.induction with
    | sw x y l => rfl
    | cons z g => simp [labelling‚ÇÄ] at h
  | cons z f hr =>
    cases g using SListQuiv.induction with
    | sw x y l => simp [labelling‚ÇÄ] at h
    | cons z f =>
      simp only [labelling‚ÇÄ, Nat.add_right_cancel_iff] at h
      obtain rfl := hr h
      rfl

lemma eq_of_labelling‚ÇÄ_eq' {i j k : SListQuiv C} {f : i ‚ü∂ j} {g : i ‚ü∂ k}
    (h : labelling‚ÇÄ f = labelling‚ÇÄ g) :
    j = k := by
  induction f using SListQuiv.induction generalizing k with
  | sw x y l => cases g using SListQuiv.induction with
    | cons z _ => simp [labelling‚ÇÄ] at h
    | sw x y l => rfl
  | cons z f hr => cases g using SListQuiv.induction with
    | sw x y l => simp [labelling‚ÇÄ] at h
    | cons z _ =>
      simp only [labelling‚ÇÄ, Nat.add_right_cancel_iff] at h
      obtain rfl := hr h
      rfl

lemma eq_of_labelling‚ÇÄ_eq'' {i j k : SListQuiv C} {f : i ‚ü∂ j} {g : k ‚ü∂ j}
    (h : labelling‚ÇÄ f = labelling‚ÇÄ g) :
    i = k := by
  induction f using SListQuiv.induction generalizing k with
  | sw x y l => cases g using SListQuiv.induction with
    | cons z _ => simp [labelling‚ÇÄ] at h
    | sw x y l => rfl
  | cons z f hr => cases g using SListQuiv.induction with
    | sw x y l => simp [labelling‚ÇÄ] at h
    | cons z _ =>
      simp only [labelling‚ÇÄ, Nat.add_right_cancel_iff] at h
      obtain rfl := hr h
      rfl

lemma _root_.FreeMonoid.mul_eq_of_eq_mul_of {Œ± : Type*} {u v : FreeMonoid Œ±} {a a' : Œ±}
    (h : u * (.of a) = v * (.of a')) : u = v ‚àß a = a' := by
  suffices h : a = a' by
    subst h
    simpa using h
  have toList_eq := congr(FreeMonoid.toList $h)
  have length_eq := congr(List.length $toList_eq)
  simp only [FreeMonoid.toList_mul, FreeMonoid.toList_of, List.length_append,
    List.length_cons, List.length_nil, zero_add, Nat.add_right_cancel_iff] at toList_eq length_eq
  simpa [length_eq] using congr(List.drop (FreeMonoid.toList u).length $toList_eq)

lemma eq_of_w‚ÇÄ_app_eq {i j : FreeSListQuiv C} {f g : i ‚ü∂ j} (h : w‚ÇÄ.app f = w‚ÇÄ.app g) :
    f = g := by
  induction f using FreeSListQuiv.hom_induction with
  | id => cases g using FreeSListQuiv.hom_induction with
    | @comp i j k p q h' =>
      have := congr(FreeMonoid.length $h)
      simp [labelling‚ÇÅMon] at this
    | id => rfl
  | @comp u v w p q h' =>
    cases g using FreeSListQuiv.hom_induction with
    | id =>
      have := congr(FreeMonoid.length $h)
      simp [labelling‚ÇÅMon] at this
    | @comp u' v' w' p' q' h'' =>
      simp only [weight.weight_comp, FreeSListQuiv.mkWeight_app_Œπ, labelling‚ÇÅMon] at h
      have : labelling‚ÇÄ q = labelling‚ÇÄ q' := (FreeMonoid.mul_eq_of_eq_mul_of h).2
      obtain rfl : v = v' := eq_of_labelling‚ÇÄ_eq'' this
      obtain rfl : q = q' := eq_of_labelling‚ÇÄ_eq this
      simp only [mul_left_inj] at h
      obtain rfl := h' h
      rfl

@[simp]
lemma w‚ÇÇ_app_eq'' (n : ‚Ñï) {i j : FreeSListQuiv C} (f : i ‚ü∂ j) (hn : n + 2 = i.length) :
    AnToAinfMonoid _ ((wFin n).app f) = Ainf.groupToMonoid (w‚ÇÇ.app f) := by
  induction f using FreeSListQuiv.hom_induction with
  | id => simp [w‚ÇÇ]
  | @comp u v p q h r =>
    have := A‚ÇôLabelling_to_Ainf n h <| by
      have := FreeSListQuiv.length_eq_of_hom q
      grind
    simp [this, labelling‚ÇÇMon, r hn]

lemma eq_of_w‚ÇÄ_app_eq' {i j k : FreeSListQuiv C} {f : i ‚ü∂ j} {g : i ‚ü∂ k}
    (h : w‚ÇÄ.app f = w‚ÇÄ.app g) :
    j = k := by
  induction f using FreeSListQuiv.hom_induction generalizing k with
  | id =>
    cases g using FreeSListQuiv.hom_induction with
    | id => rfl
    | comp p q _ =>
      symm at h
      simp [labelling‚ÇÅMon] at h
  | @comp u v w p q r => cases g using FreeSListQuiv.hom_induction with
    | id => simp [labelling‚ÇÅMon] at h
    | @comp u' v' w' p' q' r' =>
      simp only [weight.weight_comp, FreeSListQuiv.mkWeight_app_Œπ, labelling‚ÇÅMon,
        forall_const] at h r r'
      have := FreeMonoid.mul_eq_of_eq_mul_of h
      grind [eq_of_labelling‚ÇÄ_eq', eq_of_labelling‚ÇÄ_eq]

lemma eq_of_w‚ÇÄ_eq'' {i j k : FreeSListQuiv C} {f : i ‚ü∂ k} {g : j ‚ü∂ k}
    (h : w‚ÇÄ.app f = w‚ÇÄ.app g) :
    i = j := by
  induction f using FreeSListQuiv.hom_induction generalizing j with
  | id =>
    cases g using FreeSListQuiv.hom_induction with
    | id => rfl
    | comp p q _ =>
      symm at h
      simp [labelling‚ÇÅMon] at h
  | @comp u v w p q r => cases g using FreeSListQuiv.hom_induction with
    | id => simp [labelling‚ÇÅMon] at h
    | @comp u' v' w' p' q' r' =>
      simp only [weight.weight_comp, FreeSListQuiv.mkWeight_app_Œπ, labelling‚ÇÅMon,
        forall_const] at h r r'
      have := FreeMonoid.mul_eq_of_eq_mul_of h
      obtain rfl : v = v' := eq_of_labelling‚ÇÄ_eq'' this.2
      grind [eq_of_labelling‚ÇÄ_eq', eq_of_labelling‚ÇÄ_eq]

abbrev valEmb (n : ‚Ñï) : FreeMonoid (Fin n) ‚Üí* FreeMonoid ‚Ñï := FreeMonoid.lift (fun x ‚Ü¶ .of x.val)

lemma w‚ÇÄFin_consPath_map (n : ‚Ñï) {i j : FreeSListQuiv C} (f : i ‚ü∂ j) (x : C)
      (hn : i.length <= n + 2) :
    (w‚ÇÄFin (n + 1)).app (x ::_‚Çò f) = succMon _ (w‚ÇÄFin n |>.app f) := by
  induction f using FreeSListQuiv.hom_induction with
  | id => simp
  | @comp u v w p q r =>
      simp only [Functor.map_comp, ‚Üê FreeSListQuiv.cons_map_def, weight.weight_comp, r hn,
        FreeSListQuiv.mkWeight_app_Œπ, finLabelling‚ÇÅMon, finLabelling‚ÇÄ, labelling‚ÇÄ,
        Fin.ofNat_eq_cast, map_mul, FreeMonoid.lift_eval_of, mul_right_inj]
      congr
      ext
      simp only [Fin.val_natCast, Fin.val_succ]
      rw [Nat.mod_eq_of_lt, Nat.mod_eq_of_lt] <;>
      ¬∑ have := labelling‚ÇÄ_lt q
        simp at hn
        have l‚ÇÅ : u.length = v.length := FreeSListQuiv.length_eq_of_hom p
        rw [‚Üê l‚ÇÅ] at this
        grind

lemma w‚ÇÄ_consPath_map {i j : FreeSListQuiv C} (f : i ‚ü∂ j) (x : C) :
    w‚ÇÄ.app (x ::_‚Çò f) = shift'Mon 1 (w‚ÇÄ.app f) := by
  induction f using FreeSListQuiv.hom_induction with
  | id => simp
  | @comp u v w p q r => simpa [‚Üê FreeSListQuiv.cons_map_def, labelling‚ÇÅMon, labelling‚ÇÄ] using r

lemma w‚ÇÄ_prependPath_map (l : FreeSListQuiv C) {i j : FreeSListQuiv C} (f : i ‚ü∂ j) :
    w‚ÇÄ.app (l ++‚Çò f) = shift'Mon l.length (w‚ÇÄ.app f) := by
  cases l with | h l =>
  induction l with
  | nil =>
    induction f using FreeSListQuiv.hom_induction with
    | id => simp
    | @comp u v w p q r =>
      simp [labelling‚ÇÅMon, FreeSListQuiv.append_nil_map]
  | cons z l' r' =>
    induction f using FreeSListQuiv.hom_induction with
    | id => simp
    | @comp u v w p q r =>
      simp only [toList_length, FreeSListQuiv.Œπ_length, length_cons, Functor.map_comp,
        weight.weight_comp, FreeSListQuiv.mkWeight_app_Œπ, map_mul] at r r'
      simp [FreeSListQuiv.cons_obj_eq, FreeSListQuiv.append_cons_map, w‚ÇÄ_consPath_map,
        ‚Üê map_mul, r', shift'Mon_self]

lemma valEmb_w‚ÇÄFin {i j : FreeSListQuiv C} (f : i ‚ü∂ j) (n : ‚Ñï)
    (hn : i.length = n + 2) :
    valEmb _ (w‚ÇÄFin n |>.app f) = w‚ÇÄ.app f := by
  induction f using FreeSListQuiv.hom_induction with
  | id => simp
  | @comp u v w p q r =>
    have := labelling‚ÇÄ_lt q;
    have l‚ÇÅ : u.length = v.length := FreeSListQuiv.length_eq_of_hom p
    have := r hn
    simp [finLabelling‚ÇÅMon, finLabelling‚ÇÄ, r hn, labelling‚ÇÅMon,
      Nat.mod_eq_of_lt (a := labelling‚ÇÄ q) (b := n + 1) (by grind [Paths.of_obj])]

lemma eq_of_w‚ÇÄFin_eq {i j : FreeSListQuiv C} {f g : i ‚ü∂ j} (n : ‚Ñï)
    (hn : i.length = n + 2) (h : (w‚ÇÄFin n).app f = (w‚ÇÄFin n).app g) :
    f = g := by
  apply eq_of_w‚ÇÄ_app_eq
  induction f using FreeSListQuiv.hom_induction generalizing n with
  | id => cases g using FreeSListQuiv.hom_induction with
    | id => simp
    | comp p q _ => symm at h; simp [finLabelling‚ÇÅMon] at h
  | @comp u v w p q hr => cases g using FreeSListQuiv.hom_induction with
    | id => simp [finLabelling‚ÇÅMon] at h
    | @comp u' v' w p' q' r' =>
      simp only [toList_length, FreeSListQuiv.Œπ_length, weight.weight_comp,
        FreeSListQuiv.mkWeight_app_Œπ, finLabelling‚ÇÅMon, forall_const] at hr h r'
      have := FreeMonoid.mul_eq_of_eq_mul_of h
      have l_e := FreeSListQuiv.length_eq_of_hom p'
      have l_e' := FreeSListQuiv.length_eq_of_hom p
      simp only [toList_length, FreeSListQuiv.Œπ_length] at l_e l_e' hn p
      simp only [finLabelling‚ÇÄ, Fin.ofNat_eq_cast, Fin.ext_iff, Fin.val_natCast] at this
      have e : w‚ÇÄ.app p = w‚ÇÄ.app p' := by
        have := congr(valEmb _ $(this.1))
        rwa [valEmb_w‚ÇÄFin, valEmb_w‚ÇÄFin] at this <;> grind
      simp only [weight.weight_comp, e, FreeSListQuiv.mkWeight_app_Œπ, labelling‚ÇÅMon, mul_right_inj]
      congr 1
      rw [Nat.mod_eq_of_lt, Nat.mod_eq_of_lt] at this
      ¬∑ grind
      ¬∑ have := labelling‚ÇÄ_lt q'
        grind
      ¬∑ have := labelling‚ÇÄ_lt q
        simp
        grind

lemma eq_of_w‚ÇÄFin_eq' {i j k : FreeSListQuiv C} {f : i ‚ü∂ j} {g : i ‚ü∂ k} (n : ‚Ñï)
    (hn : i.length = n + 2) (h : (w‚ÇÄFin n).app f = (w‚ÇÄFin n).app g) :
    j = k := by
  apply eq_of_w‚ÇÄ_app_eq' (f := f) (g := g)
  induction f using FreeSListQuiv.hom_induction generalizing n with
  | id => cases g using FreeSListQuiv.hom_induction with
    | id => simp
    | comp p q _ => symm at h; simp [finLabelling‚ÇÅMon] at h
  | @comp u v w p q hr => cases g using FreeSListQuiv.hom_induction with
    | id => simp [finLabelling‚ÇÅMon] at h
    | @comp u' v' w p' q' r' =>
      simp only [toList_length, FreeSListQuiv.Œπ_length, weight.weight_comp,
        FreeSListQuiv.mkWeight_app_Œπ, finLabelling‚ÇÅMon, forall_const] at hr h r'
      have := FreeMonoid.mul_eq_of_eq_mul_of h
      have l_e := FreeSListQuiv.length_eq_of_hom p'
      have l_e' := FreeSListQuiv.length_eq_of_hom p
      simp only [toList_length, FreeSListQuiv.Œπ_length, finLabelling‚ÇÄ, Fin.ofNat_eq_cast,
        Fin.ext_iff, Fin.val_natCast, weight.weight_comp,
        FreeSListQuiv.mkWeight_app_Œπ] at l_e l_e' p this hn ‚ä¢
      have e : w‚ÇÄ.app p = w‚ÇÄ.app p' := by
        have := congr(valEmb _ $(this.1))
        rwa [valEmb_w‚ÇÄFin, valEmb_w‚ÇÄFin] at this <;> grind
      simp only [e, labelling‚ÇÅMon, mul_right_inj]
      congr 1
      rw [Nat.mod_eq_of_lt, Nat.mod_eq_of_lt] at this
      ¬∑ grind
      ¬∑ have := labelling‚ÇÄ_lt q'
        grind
      ¬∑ have := labelling‚ÇÄ_lt q
        grind

private lemma _root_.List.eq_cons_cons_of_length_eq_add_two {n : ‚Ñï}
    (l : List C) (h : l.length = n + 2) : ‚àÉ (a b : C) (l' : List C), l = a::b::l' := by
  induction l using List.twoStepInduction <;> grind

lemma exists_hom_of_weight_eq (i : FreeSListQuiv C) (n : ‚Ñï) (hj : i.length = n + 2)
    (w : FreeMonoid (Fin (n + 1))) :
    ‚àÉ j : FreeSListQuiv C, ‚àÉ f : i ‚ü∂ j, (w‚ÇÄFin n).app f = w := by
  induction w generalizing i with
  | one =>
    use i, (ùüô _)
    simp
  | of x =>
    cases i with |_ i
    induction i generalizing n with
    | nil => grind
    | cons a l r =>
      simp only [toList_length, FreeSListQuiv.Œπ_length, length_cons, Nat.add_right_cancel_iff] at hj
      cases x using Fin.cases with
      | zero =>
        cases l with
        | nil => grind
        | cons b l =>
          use (FreeSListQuiv.Œπ C |>.obj ( b ::‚Ä¶ a ::‚Ä¶ l)),
            (FreeSListQuiv.Œπ C |>.map <| .swap a b l)
          simp only [FreeSListQuiv.mkWeight_app_Œπ]
          rfl
      | succ i =>
        cases n with
        | zero => exact i.elim0
        | succ n =>
          obtain ‚ü®j‚ÇÄ, f‚ÇÄ, hj‚ÇÄ‚ü© := r n i hj
          use (a ::_ j‚ÇÄ), (a ::_‚Çò f‚ÇÄ)
          simp [w‚ÇÄFin_consPath_map n f‚ÇÄ a (by grind), hj‚ÇÄ]
  | mul x y hx hy =>
    obtain ‚ü®j‚ÇÄ, f‚ÇÄ, rfl‚ü© := hx i hj
    obtain ‚ü®j‚ÇÅ, f‚ÇÅ, rfl‚ü© := hy j‚ÇÄ (FreeSListQuiv.length_eq_of_hom f‚ÇÄ ‚ñ∏ hj)
    use j‚ÇÅ, f‚ÇÄ ‚â´ f‚ÇÅ
    simp

private lemma exists_cons_eq_of_weight_eq_shift_quiv
    {w : FreeMonoid ‚Ñï} {i j : SListQuiv C}
    {f : i ‚ü∂ j}
    (h : w‚ÇÄ.app (FreeSListQuiv.Œπ C |>.map f) = shift'Mon 1 w) (hij : 1 ‚â§ i.length) :
    ‚àÉ x : C, ‚àÉ i' j' : SListQuiv C, ‚àÉ (f' : i' ‚ü∂ j'),
    ‚àÉ hi : (x ::‚Ä¶ i') = i, ‚àÉ hj : (x ::‚Ä¶ j') = j,
    (FreeSListQuiv.Œπ C |>.map f) =
    eqToHom (by rw [‚Üê hi]; rfl) ‚â´
      (FreeSListQuiv.cons x |>.map (FreeSListQuiv.Œπ C |>.map f')) ‚â´
      eqToHom (by rw [‚Üê hj]; rfl) := by
  cases f using SListQuiv.induction with
  | sw x y l =>
    simp only [FreeSListQuiv.mkWeight_app_Œπ, ‚Üê FreeSListQuiv.cons_map_def, cons.injEq] at h ‚ä¢
    cases w with
    | h0 => simp [labelling‚ÇÅMon] at h
    | ih x xs =>
      simp only [labelling‚ÇÅMon, labelling‚ÇÄ, map_mul, FreeMonoid.lift_eval_of] at h
      have := congr(FreeMonoid.length $h)
      simp only [FreeMonoid.length_of, FreeMonoid.length_mul, Nat.left_eq_add,
        FreeMonoid.length_eq_zero] at this
      simp only [this, mul_one] at h
      have := FreeMonoid.of_injective h
      simp at this
  | @cons x i j f =>
    use x, i, j, f, rfl, rfl
    simp [‚Üê FreeSListQuiv.cons_map_def]

lemma exists_cons_eq_of_weight_eq_shift
    {w : FreeMonoid ‚Ñï} {i j : FreeSListQuiv C}
    {f : i ‚ü∂ j}
    (h : w‚ÇÄ.app f = shift'Mon 1 w) (hij : 1 ‚â§ i.length) :
    ‚àÉ x : C, ‚àÉ i' j' : FreeSListQuiv C, ‚àÉ (f' : i' ‚ü∂ j'),
    ‚àÉ hi : (x ::_ i') = i, ‚àÉ hj : (x ::_ j') = j,
    f = eqToHom hi.symm ‚â´ (x ::_‚Çò f') ‚â´ eqToHom hj := by
  induction f using FreeSListQuiv.hom_induction generalizing w with
  | @id i' =>
      simp only [toList_length, FreeSListQuiv.Œπ_length] at hij
      obtain ‚ü®k, t‚ü© := Nat.exists_eq_add_of_le hij
      cases i' with | nil => grind | cons x i‚ÇÄ =>
      use x, i‚ÇÄ, i‚ÇÄ, ùüô _
      simp [‚Üê FreeSListQuiv.cons_obj_eq]
  | @comp i' j' k' p q hr =>
      have u := w.reverse_reverse
      rw [‚Üê u] at h
      generalize w.reverse = w' at h
      cases w' with
      | h0 =>
        have : FreeMonoid.reverse (Œ± := ‚Ñï) 1 = 1 := rfl
        simp [this, labelling‚ÇÅMon] at h
      | ih x xs =>
        simp only [weight.weight_comp, FreeSListQuiv.mkWeight_app_Œπ, FreeMonoid.reverse_mul,
          FreeMonoid.reverse_of, map_mul] at h
        -- simp only [Paths.of_obj, Paths.of_map, w‚ÇÄ_comp, w‚ÇÄ_paths_of',
        --   FreeMonoid.reverse_mul, FreeMonoid.reverse_of, map_mul, FreeMonoid.lift_eval_of] at h
        dsimp [labelling‚ÇÅMon] at h
        have := FreeSListQuiv.length_eq_of_hom p
        simp only [toList_length, FreeSListQuiv.Œπ_length] at this hij
        obtain ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := FreeMonoid.mul_eq_of_eq_mul_of h
        obtain ‚ü®x‚ÇÄ, i‚ÇÄ, j‚ÇÄ, f‚ÇÄ, hi‚ÇÄ, hj‚ÇÄ, hf‚ÇÄ‚ü© := hr h‚ÇÅ hij
        obtain ‚ü®x‚ÇÅ, i‚ÇÅ, j‚ÇÅ, f‚ÇÅ, hi‚ÇÅ, hj‚ÇÅ, hf‚ÇÅ‚ü© :=
          exists_cons_eq_of_weight_eq_shift_quiv (f := q) (w := .of x)
            (by simpa [labelling‚ÇÅMon] using congr(FreeMonoid.of $h‚ÇÇ)) (by grind)
        obtain rfl : x‚ÇÄ = x‚ÇÅ := by
          rw [‚Üê hi‚ÇÅ, FreeSListQuiv.cons_obj_eq] at hj‚ÇÄ
          have := congr(FreeSListQuiv.toList $hj‚ÇÄ)
          grind [FreeSListQuiv.cons_toList, FreeSListQuiv.Œπ_toList]
        obtain rfl : j‚ÇÄ = i‚ÇÅ := by
          rw [‚Üê hi‚ÇÅ, FreeSListQuiv.cons_obj_eq] at hj‚ÇÄ
          have := congr(FreeSListQuiv.toList $hj‚ÇÄ)
          apply FreeSListQuiv.injective_toList
          grind
        use x‚ÇÄ, i‚ÇÄ, j‚ÇÅ, f‚ÇÄ ‚â´ (FreeSListQuiv.Œπ C |>.map f‚ÇÅ), hi‚ÇÄ,
          congr(FreeSListQuiv.Œπ C |>.obj $hj‚ÇÅ)
        rw [hf‚ÇÄ, hf‚ÇÅ]
        simp

/-- This is the first main "ugly lemma" where we check by hand that the relations implies that
morphisms have consistent targets -/
lemma eq_of_w‚ÇÄFin_monoidRelations {L‚ÇÅ L‚ÇÇ L‚ÇÉ : FreeSListQuiv C}
    {f : L‚ÇÅ ‚ü∂ L‚ÇÇ} {g : L‚ÇÅ ‚ü∂ L‚ÇÉ} (n : ‚Ñï)
    (hn : L‚ÇÅ.length = n + 2)
    (h : (CoxeterMatrix.A‚Çô <| n + 1).monoidRelations (w‚ÇÄFin n |>.app f) (w‚ÇÄFin n |>.app g)) :
    L‚ÇÇ = L‚ÇÉ := by
  generalize hv : (w‚ÇÄFin n).app f = v at h
  generalize hw : (w‚ÇÄFin n).app g = w at h
  cases h with | intro i' j' =>
  obtain rfl : L‚ÇÉ = L‚ÇÅ := by
    have := FreeSListQuiv.length_eq_of_hom f
    have := FreeSListQuiv.length_eq_of_hom g
    apply eq_of_w‚ÇÄFin_eq' n (g := ùüô L‚ÇÅ) (f := g) (by grind)
    simpa
  clear hw g
  cases L‚ÇÇ with | h L‚ÇÇ =>
  cases L‚ÇÉ with | h L‚ÇÉ =>
  apply FreeSListQuiv.injective_toList
  apply List.ext_getElem (FreeSListQuiv.length_eq_of_hom f).symm
  intro i hi hi'
  simp_rw [FreeSListQuiv.equiv_Œπ_obj]
  have := getElem_toList_eq_perm_apply (f := f) i
    (by grind [FreeSListQuiv.equiv_Œπ_obj])
  simp only [FreeSListQuiv.Œπ_toList] at this
  rw [this]
  suffices w‚ÇÇ.app f = 1 by simp [this]
  have := w‚ÇÇ_app_eq' f
  replace hv := congr(valEmb _ $hv)
  simp only [valEmb_w‚ÇÄFin _ _ hn] at hv
  rw [hv] at this
  simp only [map_pow, map_mul, FreeMonoid.lift_eval_of, PresentedMonoid.mk_of,
    ‚Üê Ainf.groupToMonoid_simple] at this
  rw [‚Üê map_mul (f := Ainf.groupToMonoid), ‚Üê map_pow (f := Ainf.groupToMonoid),
    ‚Üê CoxeterMatrix.toCoxeterSystem_simple, A‚Çô_m_eq,
    Ainf.toCoxeterSystem.simple_mul_simple_pow] at this
  have : Function.Injective Ainf.groupToMonoid := Ainf.monoidToGroupMulEquiv.toEquiv.symm.injective
  grind

lemma eq_of_w‚ÇÄFin_congen_rel {i j k : FreeSListQuiv C} {f : i ‚ü∂ j} {g : i ‚ü∂ k} (n : ‚Ñï)
    (hn : i.length = n + 2)
    (h : ConGen.Rel (CoxeterMatrix.A‚Çô (n + 1)).monoidRelations
      (w‚ÇÄFin n |>.app f) (w‚ÇÄFin n |>.app g)) :
    j = k := by
  generalize hv : (w‚ÇÄFin n).app f = v at h
  generalize hw : (w‚ÇÄFin n).app g = w at h
  induction h generalizing i j k f g with
  | of x y r =>
    subst hv
    subst hw
    exact eq_of_w‚ÇÄFin_monoidRelations n hn r
  | refl x => exact eq_of_w‚ÇÄFin_eq' n hn (hw ‚ñ∏ hv)
  | symm r hr => exact hr hn hw hv|>.symm
  | @trans u v w r r' hr hr' =>
    obtain ‚ü®j', f', hf'‚ü© := exists_hom_of_weight_eq i n hn v
    obtain rfl := hr hn hv hf'
    have := FreeSListQuiv.length_eq_of_hom f
    exact hr' (by grind) hf' hw
  | @mul u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ r‚ÇÅ r‚ÇÇ hr‚ÇÅ hr‚ÇÇ =>
    obtain ‚ü®k‚ÇÅ, f‚ÇÅ, hf‚ÇÅ‚ü© := exists_hom_of_weight_eq i n hn u‚ÇÅ
    obtain ‚ü®j‚ÇÅ, g‚ÇÅ, hg‚ÇÅ‚ü© := exists_hom_of_weight_eq k‚ÇÅ n
      (by have := FreeSListQuiv.length_eq_of_hom f‚ÇÅ; grind) v‚ÇÅ
    obtain ‚ü®k‚ÇÇ, f‚ÇÇ, hf‚ÇÇ‚ü© := exists_hom_of_weight_eq i n hn u‚ÇÇ
    obtain ‚ü®j‚ÇÇ, g‚ÇÇ, hg‚ÇÇ‚ü© := exists_hom_of_weight_eq k‚ÇÇ n
      (by have := FreeSListQuiv.length_eq_of_hom f‚ÇÇ; grind) v‚ÇÇ
    obtain rfl : j = j‚ÇÅ := eq_of_w‚ÇÄFin_eq' (f := f) (g := f‚ÇÅ ‚â´ g‚ÇÅ) n hn (by grind)
    obtain rfl : k = j‚ÇÇ := eq_of_w‚ÇÄFin_eq' (f := g) (g := f‚ÇÇ ‚â´ g‚ÇÇ) n hn (by grind)
    obtain rfl := hr‚ÇÅ hn hf‚ÇÅ hf‚ÇÇ
    exact hr‚ÇÇ (by have := FreeSListQuiv.length_eq_of_hom f‚ÇÅ; grind) hg‚ÇÅ hg‚ÇÇ

end SListQuiv

section Relations

/-! The following section deals with the proof of the fact that given an endomorphism `f : L ‚ü∂ L` in
`FreeSListQuiv C` whose label corresponds to a relation in `Ainf.Monoid`, i.e., whose label is one
of
- `¬´i¬ª * ¬´i¬ª`
- `¬´i¬ª * ¬´i + 1¬ª * ¬´i¬ª * ¬´i + 1¬ª * ¬´i¬ª * ¬´i + 1¬ª`
- `¬´i + 1¬ª * ¬´i¬ª * ¬´i + 1¬ª * ¬´i¬ª * ¬´i + 1¬ª * ¬´i¬ª`
- `¬´i¬ª * ¬´j¬ª * ¬´i¬ª * ¬´j¬ª` for `|j - i| ‚â• 2`

then the corresponding endomorphism in `SList` is the identity. This is the "base case" to show
that paths with equal labels give equal morphisms in `SList`.

The proofs are a bit repetitive and all follow the same pattern:
since morphisms in `FreeSListQuiv C` have constrained sources and target,
one must first "decompose" L in a way that will make naming explicit morphisms out of `L` possible,
then one introduces a "candidate" morphism that realizes almost tautologically the given label, this
candidate must then be equal to `f` because it has the same label (and source/target).
Finally one checks that the candidate morphism indeed simplifies to an identity morphism in `SList`
by invoking the relevant relation in `SList` as each one of the four cases above correspond almost
directly to some relations that defines `SList` as a quotient of `FreeSListQuiv C`. -/

open SListQuiv

private theorem map_eq_of_label_eq_sq (k : ‚Ñï) {L : FreeSListQuiv C}
    (hk : L.length = k + 2)
    (i : ‚Ñï) (hi : i < k + 1)
    (f : L ‚ü∂ L) (hwf : w‚ÇÄ.app f = FreeMonoid.of i * FreeMonoid.of i) :
    (œÄ C).map f = (œÄ C).map (ùüô L) := by
  -- Setting up some names to make things shorter later on
  let gi‚ÇÅ : C := (L.toList)[i]'(by grind)
  let gi‚ÇÇ : C := (L.toList)[i + 1]'(by grind)
  let R := FreeSListQuiv.Œπ _ |>.obj <| asSListQuiv <| List.drop (i + 2) L.toList
  let P := FreeSListQuiv.Œπ _ |>.obj <| asSListQuiv <| List.take i L.toList
  -- breaking down `L`
  have :
    L = (P>>).obj (gi‚ÇÅ ::_ (gi‚ÇÇ ::_ R)) := by
    apply FreeSListQuiv.injective_toList
    simp [gi‚ÇÅ, gi‚ÇÇ, P, R]
  let g := eqToHom this.symm ‚â´ f ‚â´ eqToHom this
  suffices (œÄ C).map g = (œÄ C).map (ùüô _) by
    simp only [Functor.map_comp, eqToHom_map, Functor.map_id, g] at this
    rw [eqToHom_comp_iff, comp_eqToHom_iff] at this
    simpa using this
  -- building a candidate morphism with the right label
  let u‚ÇÄ := FreeSListQuiv.swap gi‚ÇÅ gi‚ÇÇ R
  let u‚ÇÅ := FreeSListQuiv.swap gi‚ÇÇ gi‚ÇÅ R
  let f‚ÇÄ := u‚ÇÄ ‚â´ u‚ÇÅ
  -- The candidate morphism is equal to `g` because it has the right label
  have g_eq :
      g = ((FreeSListQuiv.Œπ _ |>.obj <|
        asSListQuiv <| List.take i L.toList)) ++‚Çò f‚ÇÄ := by
    apply eq_of_w‚ÇÄ_app_eq
    have : w‚ÇÄ.app f = w‚ÇÄ.app g := by simp [g]
    simp only [Functor.map_comp, weight.weight_comp, w‚ÇÄ_prependPath_map, toList_length,
      FreeSListQuiv.Œπ_length, asSlist‚ÇÄ_length, List.length_take, FreeSListQuiv.toList_length,
      w‚ÇÄ_swap, FreeMonoid.lift_eval_of, zero_add, f‚ÇÄ, u‚ÇÄ, u‚ÇÅ]
    grind
  -- And now the morphism we built can be reduced thanks to the relations
  apply Quotient.sound
  simpa [g_eq, ‚Üê Functor.map_id] using FreeSListQuiv.HomEquiv.prepend _ _ _ (.swap_swap gi‚ÇÅ gi‚ÇÇ _)

private theorem map_eq_of_label_eq_braid (k : ‚Ñï) {L : FreeSListQuiv C}
    (hk : L.length = k + 1 + 1) (f : L ‚ü∂ L)
    (i : ‚Ñï) (hi : i < k + 1) (hi' : i + 1 < k + 1)
    (hwf : w‚ÇÄ.app f = (FreeMonoid.of (i + 1) * FreeMonoid.of i) ^ 3) :
    (œÄ C).map f = (œÄ C).map (ùüô L) := by
  -- setting up some names to make things shorter later on
  let gi‚ÇÅ : C := (L.toList)[i]'(by grind)
  let gi‚ÇÇ : C := (L.toList)[i + 1]'(by grind)
  let gi‚ÇÉ : C := (L.toList)[i + 2]'(by grind)
  let P := FreeSListQuiv.Œπ C |>.obj <| asSListQuiv <| List.take i L.toList
  let R := FreeSListQuiv.Œπ C |>.obj <| asSListQuiv <| List.drop (i + 3) L.toList
  -- breaking down `L` as P ++ gi‚ÇÅ::gi‚ÇÇ::gi‚ÇÉ::R
  have :
      L = (P>>).obj (gi‚ÇÅ ::_ gi‚ÇÇ ::_ (gi‚ÇÉ ::_ R)) := by
    apply FreeSListQuiv.injective_toList
    simp [P, R, gi‚ÇÅ, gi‚ÇÇ, gi‚ÇÉ]
  -- Replacing `f` by a morphism with source and target decomposed.
  let g := eqToHom this.symm ‚â´ f ‚â´ eqToHom this
  suffices (œÄ C).map g = (œÄ C).map (ùüô _) by
    simpa [Functor.map_comp, eqToHom_map, Functor.map_id, g, eqToHom_comp_iff,
      comp_eqToHom_iff] using this
  -- building a candidate morphism from `gi‚ÇÅ::gi‚ÇÇ::gi‚ÇÉ::R` to itself with the right label.
  -- The 6 morphisms below simplify via an "hexagon"-type relation.
  let f‚ÇÄ :=
    (gi‚ÇÅ ::_‚Çò (FreeSListQuiv.swap gi‚ÇÇ gi‚ÇÉ R)) ‚â´
      FreeSListQuiv.swap gi‚ÇÅ gi‚ÇÉ (gi‚ÇÇ ::_ R) ‚â´
      (gi‚ÇÉ ::_‚Çò FreeSListQuiv.swap gi‚ÇÅ gi‚ÇÇ R) ‚â´
      (FreeSListQuiv.swap gi‚ÇÉ gi‚ÇÇ (gi‚ÇÅ ::_ R)) ‚â´
      (gi‚ÇÇ ::_‚Çò FreeSListQuiv.swap gi‚ÇÉ gi‚ÇÅ R) ‚â´
      (FreeSListQuiv.swap gi‚ÇÇ gi‚ÇÅ (gi‚ÇÉ ::_ R))
  -- Because of labels, f‚ÇÄ is equal to `g`.
  have g_eq : g = (P>>).map f‚ÇÄ := by
    apply eq_of_w‚ÇÄ_app_eq
    simp only [Functor.map_comp, weight.weight_comp, w‚ÇÄ_prependPath_map, toList_length,
      w‚ÇÄ_consPath_map, w‚ÇÄ_swap, FreeMonoid.lift_eval_of, zero_add, f‚ÇÄ]
    have P_length : P.length = i := by grind
    have : w‚ÇÄ.app f = w‚ÇÄ.app g := by simp [g]
    simp only [‚Üê this, hwf, P_length, add_comm 1 i]
    grind [pow_three]
  -- Now it just remains to show that f‚ÇÄ simplifies.
  simp only [g_eq, ‚Üê Functor.map_id]
  apply prepend_congr
  have := swap_hexagon gi‚ÇÅ gi‚ÇÇ gi‚ÇÉ ((œÄ C).obj R)
  simp only [œÄ_obj_cons, Functor.map_comp, œÄ_map_cons, eqToHom_refl, Category.comp_id,
    Category.id_comp, Functor.map_id, f‚ÇÄ, swap_œÄ_def]
  simp [‚Üêreassoc_of% this, swap_swap_assoc, ‚Üê Functor.map_comp_assoc]

theorem map_eq_of_label_eq_braid_inv (k : ‚Ñï) {L : FreeSListQuiv C}
    (hk : L.length = k + 1 + 1) (f : L ‚ü∂ L)
    (i : ‚Ñï) (hi' : i + 1 < k + 1)
    (hwf : w‚ÇÄ.app f = (FreeMonoid.of i * FreeMonoid.of (i + 1)) ^ 3) :
    (œÄ C).map f = (œÄ C).map (ùüô L) := by
  -- setting up some names to make things shorter later on
  let gi‚ÇÅ : C := (L.toList)[i]'(by grind)
  let gi‚ÇÇ : C := (L.toList)[i + 1]'(by grind)
  let gi‚ÇÉ : C := (L.toList)[i + 2]'(by grind)
  let P := FreeSListQuiv.Œπ C |>.obj <| asSListQuiv <| List.take i L.toList
  let R := FreeSListQuiv.Œπ C |>.obj <| asSListQuiv <| List.drop (i + 3) L.toList
  -- breaking down `L` as P ++ gi‚ÇÅ::gi‚ÇÇ::gi‚ÇÉ::R
  have :
      L = (P>>).obj
        (gi‚ÇÅ ::_ gi‚ÇÇ ::_ gi‚ÇÉ ::_  R) := by
    apply FreeSListQuiv.injective_toList
    simp [P, R, gi‚ÇÅ, gi‚ÇÇ, gi‚ÇÉ]
  -- Replacing `f` by a morphism with source and target decomposed.
  let g := eqToHom this.symm ‚â´ f ‚â´ eqToHom this
  suffices (œÄ C).map g = (œÄ C).map (ùüô _) by
    simpa [Functor.map_comp, eqToHom_map, Functor.map_id, g, eqToHom_comp_iff,
      comp_eqToHom_iff] using this
  -- building a candidate morphism from `gi‚ÇÅ::gi‚ÇÇ::gi‚ÇÉ::R` to itself with the right label.
  -- The 6 morphisms below simplify via an "hexagon"-type relation.
  let u‚ÇÄ := FreeSListQuiv.swap gi‚ÇÅ gi‚ÇÇ (gi‚ÇÉ ::_ R)
  let u‚ÇÅ := gi‚ÇÇ ::_‚Çò FreeSListQuiv.swap gi‚ÇÅ gi‚ÇÉ R
  let u‚ÇÇ := FreeSListQuiv.swap gi‚ÇÇ gi‚ÇÉ (gi‚ÇÅ ::_ R)
  let u‚ÇÉ := gi‚ÇÉ ::_‚Çò FreeSListQuiv.swap gi‚ÇÇ gi‚ÇÅ R
  let u‚ÇÑ := FreeSListQuiv.swap gi‚ÇÉ gi‚ÇÅ (gi‚ÇÇ ::_ R)
  let u‚ÇÖ := gi‚ÇÅ ::_‚Çò FreeSListQuiv.swap gi‚ÇÉ gi‚ÇÇ R
  let f‚ÇÄ := u‚ÇÄ ‚â´ u‚ÇÅ ‚â´ u‚ÇÇ ‚â´ u‚ÇÉ ‚â´ u‚ÇÑ ‚â´ u‚ÇÖ
  -- Because of labels, f‚ÇÄ is equal to `g`.
  have g_eq : g = (P>>).map f‚ÇÄ := by
    apply eq_of_w‚ÇÄ_app_eq
    simp only [Functor.map_comp, weight.weight_comp, w‚ÇÄ_prependPath_map, toList_length, w‚ÇÄ_swap,
      FreeMonoid.lift_eval_of, zero_add, w‚ÇÄ_consPath_map, f‚ÇÄ, u‚ÇÄ, u‚ÇÅ, u‚ÇÇ, u‚ÇÉ, u‚ÇÑ, u‚ÇÖ]
    have P_length : P.length = i := by grind
    have : w‚ÇÄ.app f = w‚ÇÄ.app g := by simp [g]
    simp only [‚Üê this, hwf, P_length, add_comm 1 i]
    grind [pow_three]
  -- Now it just remains to show that f‚ÇÄ simplifies.
  simp only [g_eq, ‚Üê Functor.map_id]
  apply prepend_congr
  have := swap_hexagon gi‚ÇÅ gi‚ÇÇ gi‚ÇÉ ((œÄ C).obj R)
  simp only [œÄ_obj_cons, Functor.map_comp, swap_œÄ_def, œÄ_map_cons, Functor.map_id,
    f‚ÇÄ, u‚ÇÄ, u‚ÇÅ, u‚ÇÇ, u‚ÇÉ, u‚ÇÑ, u‚ÇÖ]
  simp [reassoc_of% this, ‚Üê Functor.map_comp_assoc, ‚Üê Functor.map_comp]

private theorem map_eq_of_label_eq_comm
    (k : ‚Ñï) {L : FreeSListQuiv C}
    (hk : L.length = k + 1 + 1) (f : L ‚ü∂ L) (i : ‚Ñï)
    (j : ‚Ñï) (hj : j < k + 1)
    (hwf : w‚ÇÄ.app f = (FreeMonoid.of i * FreeMonoid.of j) ^ 2)
    (h_lt : i < j) (hij : i + 1 ‚â† j) :
    (œÄ C).map f = (œÄ C).map (ùüô L) := by
  obtain ‚ü®j, rfl‚ü© := Nat.exists_eq_add_of_lt (show i + 1 < j by grind)
  -- Setting up some names to make things shorter later on
  let gi‚ÇÅ : C := (L.toList)[i]'(by grind)
  let gi‚ÇÇ : C := (L.toList)[i + 1]'(by grind)
  let gi‚ÇÉ : C := (L.toList)[i + 1 + j + 1]'(by grind)
  let gi‚ÇÑ : C := (L.toList)[i + 1 + j + 2]'(by grind)
  let P := FreeSListQuiv.Œπ C |>.obj <| asSListQuiv <| List.take i L.toList
  let Q := FreeSListQuiv.Œπ C |>.obj <| asSListQuiv <| List.take j <| List.drop (i + 2) L.toList
  let R := FreeSListQuiv.Œπ C |>.obj <| asSListQuiv <| List.drop (i + 1 + j + 3) L.toList
  -- breaking down `L` as P ++ [a,b] ++ Q ++ [c, d] ++ R
  have : L = (P>>).obj (gi‚ÇÅ ::_ gi‚ÇÇ ::_ ((Q>>).obj <| gi‚ÇÉ ::_ gi‚ÇÑ ::_ R)) := by
    apply FreeSListQuiv.injective_toList
    simp only [show i + 1 + j + 1 = i + 2 + j by grind, FreeSListQuiv.appendPath_toList,
      FreeSListQuiv.Œπ_toList, asSListQuiv_toList, FreeSListQuiv.cons_toList, List.getElem_cons_drop,
      P, gi‚ÇÅ, gi‚ÇÇ, Q, gi‚ÇÉ, gi‚ÇÑ, R]
    simp [show i + 1 + j + 2 = (i + 2 + j) + 1 by grind]
  -- Replacing `f` by a morphism with source and target decomposed.
  let g := eqToHom this.symm ‚â´ f ‚â´ eqToHom this
  suffices (œÄ C).map g = (œÄ C).map (ùüô _) by
    simp only [Functor.map_comp, eqToHom_map, Functor.map_id, g] at this
    rw [eqToHom_comp_iff, comp_eqToHom_iff] at this
    simpa using this
  -- building a candidate morphism with the right label.
  let v‚ÇÅ :=
    (((P>>).map <| FreeSListQuiv.swap gi‚ÇÅ gi‚ÇÇ <|
        (Q>>).obj <| gi‚ÇÉ ::_ gi‚ÇÑ ::_ R)) ‚â´
      ((P>>).map <| gi‚ÇÇ ::_‚Çò gi‚ÇÅ ::_‚Çò ((Q>>).map <| FreeSListQuiv.swap gi‚ÇÉ gi‚ÇÑ R)) ‚â´
      ((P>>).map <| FreeSListQuiv.swap gi‚ÇÇ gi‚ÇÅ <|
        (Q>>).obj <| gi‚ÇÑ ::_ gi‚ÇÉ ::_ R ) ‚â´
      ((P>>).map <| gi‚ÇÅ ::_‚Çò gi‚ÇÇ ::_‚Çò (Q>>).map <| FreeSListQuiv.swap gi‚ÇÑ gi‚ÇÉ R)
  have g_eq : g = v‚ÇÅ := by
    apply eq_of_w‚ÇÄ_app_eq
    simp only [weight.weight_comp, w‚ÇÄ_prependPath_map, toList_length, FreeSListQuiv.Œπ_length,
      asSlist‚ÇÄ_length, List.length_take, FreeSListQuiv.toList_length, w‚ÇÄ_swap,
      FreeMonoid.lift_eval_of, zero_add, w‚ÇÄ_consPath_map, List.length_drop, P, Q, v‚ÇÅ]
    have P_length : P.length = i := by grind
    have : w‚ÇÄ.app f = w‚ÇÄ.app g := by simp [g]
    grind [pow_two]
  -- Now it just remains to show that f‚ÇÄ simplifies.
  simp only [g_eq, ‚Üê Functor.map_id, v‚ÇÅ, ‚Üê Functor.map_comp]
  apply prepend_congr
  have := swap_natural gi‚ÇÅ gi‚ÇÇ ((œÄ C).map <| (Q>>).map <| FreeSListQuiv.swap gi‚ÇÉ gi‚ÇÑ R)
  simp only [œÄ_obj_cons, Functor.map_comp, swap_œÄ_def, eqToHom_refl, Category.comp_id,
    Category.id_comp, œÄ_map_cons, reassoc_of% this, swap_swap_assoc, Functor.map_id]
  simp only [‚Üê Functor.map_id, ‚Üê Functor.map_comp]
  congr 2
  apply prepend_congr
  simp [swap_œÄ_def, œÄ_obj_cons]

private theorem map_eq_of_label_eq_comm_inv
    (k : ‚Ñï) {L : FreeSListQuiv C}
    (hk : L.length = k + 1 + 1) (f : L ‚ü∂ L) (i : ‚Ñï)
    (hi : i < k + 1) (j : ‚Ñï) (hj : j < k + 1)
    (hwf : w‚ÇÄ.app f = (FreeMonoid.of i * FreeMonoid.of j) ^ 2)
    (hji : j + 1 ‚â† i)
    (hij : j < i) :
    (œÄ C).map f = (œÄ C).map (ùüô L) := by
  obtain ‚ü®i, rfl‚ü© := Nat.exists_eq_add_of_lt (show j + 1 < i by grind)
  -- Setting up some names to make things shorter later on
  let gi‚ÇÅ : C := (L.toList)[j]'(by grind)
  let gi‚ÇÇ : C := (L.toList)[j + 1]'(by grind)
  let gi‚ÇÉ : C := (L.toList)[j + 1 + i + 1]'(by grind)
  let gi‚ÇÑ : C := (L.toList)[j + 1 + i + 2]'(by grind)
  let P := FreeSListQuiv.Œπ C |>.obj <| asSListQuiv <| List.take j L.toList
  let Q := FreeSListQuiv.Œπ C |>.obj <| asSListQuiv <| List.take i <| List.drop (j + 2) L.toList
  let R := FreeSListQuiv.Œπ C |>.obj <| asSListQuiv <| List.drop (j + 1 + i + 3) L.toList
  -- breaking down `L` as P ++ [a,b] ++ Q ++ [c, d] ++ R
  have :
    L = (P>>).obj (gi‚ÇÅ ::_ gi‚ÇÇ ::_ ((Q>>).obj <| gi‚ÇÉ ::_ gi‚ÇÑ ::_ R)) := by
    apply FreeSListQuiv.injective_toList
    simp only [show j + 1 + i + 1 = j + 2 + i by grind, FreeSListQuiv.appendPath_toList,
      FreeSListQuiv.Œπ_toList, asSListQuiv_toList, FreeSListQuiv.cons_toList, List.getElem_cons_drop,
      P, gi‚ÇÅ, gi‚ÇÇ, Q, gi‚ÇÉ, gi‚ÇÑ, R]
    simp [show j + 1 + i + 2 = (j + 2 + i) + 1 by grind]
  -- Replacing `f` by a morphism with source and target decomposed.
  let g := eqToHom this.symm ‚â´ f ‚â´ eqToHom this
  suffices (œÄ C).map g = (œÄ C).map (ùüô _) by
    simp only [Functor.map_comp, eqToHom_map, Functor.map_id, g] at this
    rw [eqToHom_comp_iff, comp_eqToHom_iff] at this
    simpa using this
  -- building a candidate morphism with the right label.
  let v‚ÇÅ :=
      ((P>>).map <| gi‚ÇÅ ::_‚Çò gi‚ÇÇ ::_‚Çò ((Q>>).map <| FreeSListQuiv.swap gi‚ÇÉ gi‚ÇÑ R)) ‚â´
        ((P>>).map <| FreeSListQuiv.swap gi‚ÇÅ gi‚ÇÇ <| (Q>>).obj <| gi‚ÇÑ ::_ gi‚ÇÉ ::_ R) ‚â´
        ((P>>).map <| gi‚ÇÇ ::_‚Çò gi‚ÇÅ ::_‚Çò ((Q>>).map <| FreeSListQuiv.swap gi‚ÇÑ gi‚ÇÉ R)) ‚â´
        ((P>>).map <| FreeSListQuiv.swap gi‚ÇÇ gi‚ÇÅ <| (Q>>).obj <| gi‚ÇÉ ::_ gi‚ÇÑ ::_ R)
  have g_eq : g = v‚ÇÅ := by
    apply eq_of_w‚ÇÄ_app_eq
    simp only [weight.weight_comp, w‚ÇÄ_prependPath_map, toList_length, FreeSListQuiv.Œπ_length,
      asSlist‚ÇÄ_length, List.length_take, FreeSListQuiv.toList_length, w‚ÇÄ_consPath_map,
      List.length_drop, w‚ÇÄ_swap, FreeMonoid.lift_eval_of, zero_add, P, Q, v‚ÇÅ]
    have P_length : P.length = j := by grind
    have : w‚ÇÄ.app f = w‚ÇÄ.app g := by simp [g]
    grind [pow_two]
  -- Now it just remains to show that f‚ÇÄ simplifies.
  simp only [g_eq, ‚Üê Functor.map_id, v‚ÇÅ, ‚Üê Functor.map_comp]
  apply prepend_congr
  have := swap_natural gi‚ÇÅ gi‚ÇÇ ((œÄ C).map <| (Q>>).map <| FreeSListQuiv.swap gi‚ÇÉ gi‚ÇÑ R)
  -- have := swap_hexagon gi‚ÇÅ gi‚ÇÇ gi‚ÇÉ R
  -- 4 nonterminal simps...
  simp only [œÄ_obj_cons, Functor.map_comp, œÄ_map_cons, eqToHom_refl, Category.comp_id,
    Category.id_comp, swap_œÄ_def, ‚Üê reassoc_of% this, Functor.map_id]
  have : (œÄ C).map ((Q>>).map
      (FreeSListQuiv.swap gi‚ÇÉ gi‚ÇÑ R ‚â´ FreeSListQuiv.swap gi‚ÇÑ gi‚ÇÉ R)) = ùüô _ := by
    simp only [‚Üê Functor.map_id]
    apply prepend_congr
    simp [swap_œÄ_def, œÄ_obj_cons]
  -- simp only [swap_swap_assoc, ‚Üê Functor.map_comp]
  simp only [‚Üê Functor.map_comp_assoc, ‚Üê Functor.map_comp, this, ‚Üê Functor.map_id]
  simp

section EdgeCases

/-! The edge cases of the theorem that two paths with equal formal permutations are
equal in the quotient where the paths are between empty or singleton lists needs to be proved by
hand separately, but are fortunately not too difficult: all these path types are subsingletons! -/

private theorem eq_of_path_of_length_eq_zero {i j : FreeSListQuiv C}
    (f g : i ‚ü∂ j) (hk : i.length = 0) : f = g := by
  obtain h : j.length = 0 := (FreeSListQuiv.length_eq_of_hom f ‚ñ∏ hk)
  obtain rfl : i = []_ := FreeSListQuiv.length_eq_zero_iff.mp hk
  obtain rfl : j = []_ := FreeSListQuiv.length_eq_zero_iff.mp h
  obtain rfl : f = ùüô _ := FreeSListQuiv.eq_id_of_hom_nil f
  obtain rfl : g = ùüô _ := FreeSListQuiv.eq_id_of_hom_nil g
  rfl

private theorem eq_of_path_of_length_eq_one {i j : FreeSListQuiv C}
    (f g : i ‚ü∂ j) (hk : i.length = 1) : f = g := by
  obtain h : j.length = 1 := (FreeSListQuiv.length_eq_of_hom f ‚ñ∏ hk)
  obtain ‚ü®u, rfl‚ü© := FreeSListQuiv.length_eq_one_iff.mp hk
  obtain ‚ü®u', rfl‚ü© := FreeSListQuiv.length_eq_one_iff.mp h
  cases f using FreeSListQuiv.cases_hom_singleton
  cases g using FreeSListQuiv.cases_hom_singleton
  rfl

end EdgeCases

/-- The weight w‚ÇÇ is faithful: two formal compositions in
`FreeSListQuiv C` with same labels are equal as morphisms of
symmetric lists. This is theorem 2.3 in the paper.
-/
theorem œÄ_map_eq_of_w‚ÇÇ_eq {i j : FreeSListQuiv C} (f g : i ‚ü∂ j)
    (h : w‚ÇÇ.app f = w‚ÇÇ.app g) :
    (œÄ C).map f = (œÄ C).map g := by
  generalize hk : i.length = k
  -- The case of length ‚â§ 1 are handled in previous theorems
  obtain _ | _ | k := k
  ¬∑ simp [eq_of_path_of_length_eq_zero f g hk]
  ¬∑ simp [eq_of_path_of_length_eq_one f g hk]
  ¬∑ /- First, we reduce the equality `h` to an equality in an appropriate
    Coxeter monoid of type A‚Çô -/
    replace h := congr(Ainf.groupToMonoid $h)
    rw [‚Üê w‚ÇÇ_app_eq'' k f (by grind), ‚Üê w‚ÇÇ_app_eq'' k g (by grind)] at h
    have h := injective_AnToAinfMonoid _ h
    simp only [wFin_app_eq'] at h
    have := Quotient.exact h
    clear h
    clear h
    generalize hwf : (w‚ÇÄFin k).app f = wf at this
    generalize hwg : (w‚ÇÄFin k).app g = wg at this
    /- Then, we begin an induction on `h`, reducing it to all the
    cases for the symmetric transitive closure of the congruence
    generated by the relations in the Coxeter group -/
    induction this generalizing i j with
    | of x y h =>
      -- The case of a "pure relation"
      cases h with | intro i' j' =>
      obtain rfl : i = j := by
        apply eq_of_w‚ÇÄFin_eq' k (f := ùüô i) (g := g) (by grind)
        simpa using hwg.symm
      obtain rfl : g = ùüô _ := by
        apply eq_of_w‚ÇÄFin_eq k (by grind)
        simpa
      clear hwg
      simp only [CoxeterMatrix.A‚Çô, Matrix.of_apply, pow_ite, pow_one] at hwf
      rcases i' with ‚ü®i', hi'‚ü©
      rcases j' with ‚ü®j', hj'‚ü©
      replace hwf := congr((valEmb _) $hwf)
      simp only [Fin.ext_iff, apply_ite (f := valEmb (k + 1)), map_mul,
        FreeMonoid.lift_eval_of, map_pow, valEmb_w‚ÇÄFin (hn := hk)] at hwf
      split_ifs at hwf with h' h''
      /- Each of the Coxeter relations have been explicitly handled in previous lemmas,
      following the exact same pattern of "guessing" what the morphisms are from
      their label, and showing that the relations are satisfied once the morphism
      is known.-/
      ¬∑ subst h'
        exact map_eq_of_label_eq_sq k hk i' hi' f hwf
      ¬∑ clear h'
        rcases h'' with rfl | rfl
        ¬∑ exact map_eq_of_label_eq_braid k hk f j' hj' hi' hwf
        ¬∑ exact map_eq_of_label_eq_braid_inv k hk f i' hj' hwf
      ¬∑ push_neg at h' h''
        obtain ‚ü®hji, hij‚ü© := h''
        by_cases i' < j'
        ¬∑ exact map_eq_of_label_eq_comm k hk f i' j' (by grind) hwf
            (by grind) hij
        ¬∑ refine map_eq_of_label_eq_comm_inv k hk f i' hi' j' hj' hwf hji
            (by grind)
    | refl x =>
      subst hwf
      obtain rfl : f = g := eq_of_w‚ÇÄFin_eq k (by grind) hwg.symm
      exact .refl _
    | @symm x y r hr =>
      symm
      exact hr _ _ hk hwg hwf
    | @trans x y z r‚ÇÅ r‚ÇÇ hr‚ÇÅ hr‚ÇÇ =>
      /- In the case for transitivity, we have to lift the extra
      words that appear as actual morphisms: this is only possible
      because we reduced to the smaller group `A‚Çô`. Otherwise,
      the lables of the extra words could be too big to be represented
      by a morphism in FreeSListQuiv with `i` as source. -/
      obtain ‚ü®j‚ÇÄ, f' , hf'‚ü© := exists_hom_of_weight_eq i k hk y
      obtain rfl : j = j‚ÇÄ := by
        subst_vars
        exact eq_of_w‚ÇÄFin_congen_rel _ hk r‚ÇÅ
      have := hr‚ÇÅ f f' hk hwf hf'
      grind
    | @mul w y x z r r' hr hr' =>
      /- Same as transitivity: this is straightforward but only once
      the extra words that appear in the inductive hypotheses are
      lifted to morphisms. -/
      obtain ‚ü®j‚ÇÄ, f‚ÇÄ , hf‚ÇÄ‚ü© := exists_hom_of_weight_eq i k hk w
      obtain ‚ü®j‚ÇÅ, f‚ÇÅ , hf‚ÇÅ‚ü© := exists_hom_of_weight_eq j‚ÇÄ k
        (FreeSListQuiv.length_eq_of_hom f‚ÇÄ ‚ñ∏ hk) x
      obtain rfl : j = j‚ÇÅ :=
        eq_of_w‚ÇÄFin_eq' (f := f) (g := f‚ÇÄ ‚â´ f‚ÇÅ) k hk (by grind)
      obtain ‚ü®k‚ÇÄ, g‚ÇÄ , hg‚ÇÄ‚ü© := exists_hom_of_weight_eq i k hk y
      obtain ‚ü®k‚ÇÅ, g‚ÇÅ , hg‚ÇÅ‚ü© :=
        exists_hom_of_weight_eq k‚ÇÄ k (FreeSListQuiv.length_eq_of_hom g‚ÇÄ ‚ñ∏ hk) z
      obtain rfl : j = k‚ÇÅ :=
        eq_of_w‚ÇÄFin_eq' (f := g) (g := g‚ÇÄ ‚â´ g‚ÇÅ) k hk (by grind)
      obtain rfl : j‚ÇÄ = k‚ÇÄ := by
        subst_vars
        exact eq_of_w‚ÇÄFin_congen_rel k hk r
      have := hr f‚ÇÄ g‚ÇÄ hk hf‚ÇÄ hg‚ÇÄ
      have := hr' f‚ÇÅ g‚ÇÅ (FreeSListQuiv.length_eq_of_hom f‚ÇÄ ‚ñ∏ hk) hf‚ÇÅ hg‚ÇÅ
      obtain rfl : f = f‚ÇÄ ‚â´ f‚ÇÅ := eq_of_w‚ÇÄFin_eq k hk (by grind)
      obtain rfl : g = g‚ÇÄ ‚â´ g‚ÇÅ := eq_of_w‚ÇÄFin_eq k hk (by grind)
      grind

public section toAinf

@[grind inj]
theorem injective_toAinf_app {x y : SList C} : Function.Injective
    (@(toAinf (C := C)).app (x := x) (y := y)) := by
  intro f g h
  cases f with |_ f
  cases g with |_ g
  exact œÄ_map_eq_of_w‚ÇÇ_eq _ _ (by simpa using h)

theorem hom_eq_iff_toAinf_eq {x y : SList C} (f g : x ‚ü∂ y) :
    f = g ‚Üî toAinf.app f = toAinf.app g := by
  grind

end toAinf

public section toPerm

@[grind inj]
theorem injective_toPerm_app {x y : SList C} : Function.Injective
    (@(toPerm (C := C)).app (x := x) (y := y)) := by
  intro f g h
  cases f with |_ f
  cases g with |_ g
  simp only [toPerm, weight.postComp_app] at h
  exact injective_toAinf_app <| injective_AinfToPerm h

theorem hom_eq_iff_toPerm_eq {x y : SList C} (f g : x ‚ü∂ y) :
    f = g ‚Üî toPerm.app f = toPerm.app g :=
  ‚ü®fun h => by rw [h], fun h => by rw [injective_toPerm_app h]‚ü©

end toPerm

public section toEquiv

@[simps! -isSimp]
public def toEquiv {x y : SList C} (f : x ‚ü∂ y) :
    Fin y.length ‚âÉ Fin x.length where
  toFun j := ‚ü®toPerm.app f j, toPerm_app_lt_of_lt _ _ j.prop‚ü©
  invFun j := ‚ü®(toPerm.app f).symm j, by simpa using toPerm_app_lt_of_lt (inv f) _ j.prop‚ü©
  left_inv j := by simp
  right_inv j := by simp

@[simp, grind =]
lemma toEquiv_comp {x y z : SList C} (f : x ‚ü∂ y) (g : y ‚ü∂ z) :
    toEquiv (f ‚â´ g) = (toEquiv g).trans (toEquiv f) := by
  ext
  simp [toEquiv]

lemma toEquiv_comp_apply {x y z : SList C} (f : x ‚ü∂ y) (g : y ‚ü∂ z) (i : Fin z.length) :
    toEquiv (f ‚â´ g) i = (toEquiv f ((toEquiv g) i)) := by
  simp [toEquiv]

@[simp, grind =]
lemma toEquiv_id (x : SList C) :
    toEquiv (ùüô x) = Equiv.refl _ := by
  ext
  simp [toEquiv]

@[simp, grind =]
lemma toEquiv_eqToHom {x y : SList C} (h : x = y) :
    toEquiv (eqToHom h) = finCongr (by rw [h]) := by
  ext
  simp [toEquiv]

@[grind _=_]
lemma toEquiv_symm {x y : SList C} (f : x ‚ü∂ y) :
    (toEquiv f).symm = toEquiv (inv f) := by
  ext
  simp [toEquiv]

@[simp, grind =]
lemma toEquiv_hom_inv_apply {x y : SList C} (f : x ‚âÖ y) (t : Fin x.length) :
    (toEquiv f.hom) (toEquiv (f.inv) t) = t := by
  simp [toEquiv]

@[simp, grind =]
lemma toEquiv_inv_hom_apply {x y : SList C} (f : x ‚âÖ y) (t : Fin y.length) :
    (toEquiv f.inv) (toEquiv f.hom t) = t := by
  simp [toEquiv]

theorem hom_eq_iff_toEquiv_eq {x y : SList C} (f g : x ‚ü∂ y) :
    f = g ‚Üî (toEquiv f) = (toEquiv g) where
  mp h := by rw [h]
  mpr h := by
    rw [hom_eq_iff_toPerm_eq]
    ext k
    by_cases! hl : k < y.length
    ¬∑ exact congr($h ‚ü®k, hl‚ü©)
    ¬∑ rw [toPerm_app_eq_of_lt _ _ hl, toPerm_app_eq_of_lt _ _ ((length_eq_of_hom f) ‚ñ∏ hl)]

theorem getElem_toList_toEquiv {x y : SList C} (f : x ‚ü∂ y) (i : Fin y.length) :
     y.toList[i] = x.toList[(toEquiv f) i] := by
  cases f with | @h x y f =>
  simp only [Fin.getElem_fin, toEquiv_apply_val, œÄ_obj_toList, toPerm,
    weight.postComp_app, toAinf_œÄ]
  exact getElem_toList_eq_perm_apply f _ _

/-- An auxiliary lemma doing the heavy lifting (no pun intended) for
`exists_lift_equiv`. This is essentially a variation on `exists_hom_of_weight_eq`. -/
private lemma exists_lift_perm {x : SList C} (œÜ : Equiv.Perm (Fin x.length)) :
    ‚àÉ (y : SList C) (f : x ‚ü∂ y),
      toEquiv f = (finCongr (length_eq_of_hom f).symm).trans œÜ := by
  -- essentially exists_hom_of_weight_eq
  cases x with | h x =>
  generalize h : x.length = k
  obtain _ | _ | k := k
  ¬∑ obtain rfl : x = []_ := FreeSListQuiv.length_eq_zero_iff.mp h
    obtain rfl : œÜ = 1 := by grind
    use []~, ùüô _
    simp [nil_def]
  ¬∑ obtain ‚ü®u, rfl‚ü© := FreeSListQuiv.length_eq_one_iff.mp h
    obtain rfl : œÜ = 1 := by grind
    use u ::~ []~, ùüô _
    simp [nil_def, œÄ_obj_cons]
  ¬∑ -- This is essentially a result we already have, though we have
    -- some book-keeping to do to reduce it to this case, as
    -- we need to correct the types through some equivalences.
    have := exists_hom_of_weight_eq (C := C) x k h
    let u := hom1MulEquiv (k + 1)
    let v := (CoxeterMatrix.A‚Çô (k + 1)).monoidToGroupMulEquiv
    let w := v.trans u
    have e‚ÇÄ : ((œÄ C).obj x).length = k + 1 + 1 := by grind
    let œà : Equiv.Perm (Fin (k + 1 + 1)) := Equiv.permCongrHom (finCongr e‚ÇÄ) œÜ
    let k‚ÇÄ := w.symm œà
    obtain ‚ü®a, ha‚ü© := PresentedMonoid.surjective_mk k‚ÇÄ
    obtain ‚ü®y‚ÇÄ, f‚ÇÄ, hf‚ÇÄ‚ü© := this a
    use (œÄ C).obj y‚ÇÄ, (œÄ C).map f‚ÇÄ
    ext i
    simp only [toEquiv, toPerm, weight.postComp_app, toAinf_œÄ, Equiv.coe_fn_mk, Equiv.trans_apply,
      finCongr_apply]
    have app_eq'' := congr(Ainf.monoidToGroup $(w‚ÇÇ_app_eq'' (C := C) k f‚ÇÄ (by grind)))
    have := congr(PresentedMonoid.mk (CoxeterMatrix.A‚Çô _).monoidRelations $hf‚ÇÄ)
    rw [‚Üê wFin_app_eq'] at this
    rw [CoxeterMatrix.monoidToGroup_groupToMonoid] at app_eq''
    rw [‚Üê app_eq'', this]
    simp only [AnToAinfMonoid, ha, MulEquiv.symm_trans_apply, Equiv.permCongrHom_coe,
      CoxeterMatrix.monoidToGroupMulEquiv_symm_apply, MonoidHom.coe_comp, Function.comp_apply,
      CoxeterMatrix.monoidToGroup_groupToMonoid, k‚ÇÄ, v, u, œà, w]
    have := FreeSListQuiv.length_eq_of_hom f‚ÇÄ
    have := A‚Çô_to_perm_apply_eq (n := k + 1) (i := i.cast (by grind))
      ((hom1MulEquiv (k + 1)).symm ((finCongr e‚ÇÄ).permCongr œÜ))
    simp only [Fin.val_cast] at this
    rw [‚Üê this]
    simp [hom1MulEquiv]

public theorem exists_lift_equiv {x y : SList C} (œÜ : Fin y.length ‚âÉ Fin x.length)
    (hœÜ : ‚àÄ i : Fin y.length, y.toList[i] = x.toList[œÜ i]) :
    ‚àÉ f : x ‚ü∂ y, toEquiv f = œÜ := by
  have : y.length = x.length := by rw [‚Üê Fin.equiv_iff_eq]; exact ‚ü®œÜ‚ü©
  obtain ‚ü®z, f‚ÇÄ, hf‚ÇÄ‚ü© := exists_lift_perm <|
    (finCongr
      (show x.length = y.length by rw [‚Üê Fin.equiv_iff_eq]; exact ‚ü®œÜ.symm‚ü©)).trans œÜ
  have e‚ÇÄ : y = z := by
    apply injective_toList
    apply List.ext_getElem
    ¬∑ grind
    ¬∑ intro i hiy hiz
      change i < y.length at hiy
      change i < z.length at hiz
      change y.toList[(‚ü®i, hiy‚ü© : Fin _)] = z.toList[(‚ü®i, hiz‚ü© : Fin _)]
      have e‚ÇÄ := getElem_toList_toEquiv f‚ÇÄ ‚ü®i, hiz‚ü©
      have e‚ÇÅ := hœÜ ‚ü®i, hiy‚ü©
      rw [e‚ÇÄ, e‚ÇÅ]
      exact List.getElem_of_eq' (by simp [hf‚ÇÄ]) (by simp)
  use f‚ÇÄ ‚â´ eqToHom e‚ÇÄ.symm
  ext x
  simp [hf‚ÇÄ]

/-- Lift an equivalence `(Fin y.length ‚âÉ Fin x.length)` to
a morphism in SList. -/
public noncomputable def liftEquiv {x y : SList C} (œÜ : Fin y.length ‚âÉ Fin x.length)
    (hœÜ : ‚àÄ i : Fin y.length, y.toList[i] = x.toList[œÜ i]) :
    x ‚ü∂ y :=
  (exists_lift_equiv œÜ hœÜ).choose

@[simp, grind =]
public lemma toEquiv_liftEquiv {x y : SList C} (œÜ : Fin y.length ‚âÉ Fin x.length)
    {hœÜ : ‚àÄ i : Fin y.length, y.toList[i] = x.toList[œÜ i]} :
    toEquiv (liftEquiv œÜ hœÜ) = œÜ :=
  exists_lift_equiv œÜ hœÜ |>.choose_spec

/-- Lift an equivalence `(Fin y.length ‚âÉ Fin x.length)` to
an isomorphism in SList. -/
@[simps]
public noncomputable def liftEquivIso {x y : SList C} (œÜ : Fin y.length ‚âÉ Fin x.length)
    (hœÜ : ‚àÄ i : Fin y.length, y.toList[i] = x.toList[œÜ i]) :
    x ‚âÖ y where
  hom := liftEquiv œÜ hœÜ
  inv := liftEquiv œÜ.symm (by grind)
  hom_inv_id := by rw [hom_eq_iff_toEquiv_eq]; grind
  inv_hom_id := by rw [hom_eq_iff_toEquiv_eq]; grind

end toEquiv

end Relations

end CategoryTheory.SList
